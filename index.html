
<!DOCTYPE html>
<html lang='en' class=''>

<head>

    <meta charset='UTF-8'>
    <title>TERM[E]DITOR</title>

    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <meta name='description' content='A web-based terminal and text editor.'>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/scsaver@latest/src/scsaver.css">
    <link rel="stylesheet" href="css/style.css">

</head>

<body>
    <div id="terminal"></div>
      
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/scsaver@latest/dist/scsaver.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/typed.js/2.0.8/typed.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/daemondevin/cdn@main/StorageBin.js"></script>
    <script>
        function getRandomInteger(min, max) {
          return Math.floor(Math.random() * (max - min + 1) + min);
        }

        function pickRandomItem() {
          return arguments[getRandomInteger(0, arguments.length - 1)];
        }

        function getRandomCharacter() {
          const characterSet =
            '<>=123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$#@!&+%ゔゖユぅたガなろィづガヘ⁞びフゾッヤヲォえ”‱‰゛‽ぎだゥねたぱトハヲ‵’テるユタぱのどニペケ‥ゃ⁌どへバ※0⁁ネホゅら‖';
          const randomIndex = getRandomInteger(0, characterSet.length - 1);
          return characterSet[randomIndex];
        }

        function animateLoop(callback, delay) {
          let lastTimestamp = Date.now();
          function loop() {
            if (Date.now() - lastTimestamp >= delay) {
              callback();
              lastTimestamp = Date.now();
            }
            requestAnimationFrame(loop);
          }
          requestAnimationFrame(loop);
        }

        class Character {
          constructor() {
            this.element = document.createElement('span');
            this.update();
          }
          update() {
            this.element.textContent = getRandomCharacter();
          }
        }

        class CharacterTrail {
          constructor(charactersList = [], options) {
            this.charactersList = charactersList;
            this.options = Object.assign(
              { size: 10, offset: 0 }, options
            );
            this.trail = [];
            this.move();
          }
          iterate(callback) {
            this.trail.forEach((character, index) => {
              let isLast = (index === this.trail.length - 1);
              if (character) callback(character, index, isLast);
            });
          }
          move() {
            this.trail = [];
            let { offset, size } = this.options;
            for (let i = 0; i < size; ++i) {
              let character = this.charactersList[offset + i - size + 1];
              this.trail.push(character);
            }
            this.options.offset = 
              (offset + 1) % (this.charactersList.length + size - 1);
          }
        }

        class Raindrop {
    constructor({ container, row }) {
      this.element = document.createElement('p');
      this.create(row);
      if (container) {
        container.appendChild(this.element);
      }
      this.fall();
    }
    create(row = 20) {
      let fragment = document.createDocumentFragment();
      let characters = [];
      for (let i = 0; i < row; ++i) {
        let char = new Character();
        fragment.appendChild(char.element);
        characters.push(char);
        if (Math.random() < 0.5) {
          animateLoop(() => char.update(), getRandomInteger(1000, 5000));
        }
      }
      this.trail = new CharacterTrail(characters, { 
        size: getRandomInteger(10, 30), offset: getRandomInteger(0, 100) 
      });
      this.element.appendChild(fragment); 
    }
    fall() {
      let trail = this.trail;
      let length = trail.trail.length;
      let delay = getRandomInteger(10, 100);
      animateLoop(() => {
        trail.move();
        trail.iterate((char, index, isLast) => {
          char.element.style = `
            color: hsl(136, 100%, ${85 / length * (index + 1)}%)
          `;
          if (isLast) {
            char.update();
            char.element.style = `
              color: hsl(136, 100%, 85%);
              text-shadow:
                0 0 .5em #fff,
                0 0 .5em currentColor;
            `;
          }
        });
      }, delay);
    }
  }
    </script>
    <script>
        class TextScramble {
            constructor(el) {
              this.el = el;
              this.chars = '!<>-_\\/[]{}—=+*^?#________';
              this.update = this.update.bind(this);
            }
            setText(newText) {
              const oldText = this.el.innerText;
              const length = Math.max(oldText.length, newText.length);
              const promise = new Promise(resolve => this.resolve = resolve);
              this.queue = [];
              for (let i = 0; i < length; i++) {
                const from = oldText[i] || '';
                const to = newText[i] || '';
                const start = Math.floor(Math.random() * 40);
                const end = start + Math.floor(Math.random() * 40);
                this.queue.push({ from, to, start, end });
              }
              cancelAnimationFrame(this.frameRequest);
              this.frame = 0;
              this.update();
              return promise;
            }
            update() {
              let output = '';
              let complete = 0;
              for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i];
                if (this.frame >= end) {
                  complete++;
                  output += to;
                } else if (this.frame >= start) {
                  if (!char || Math.random() < 0.28) {
                    char = this.randomChar();
                    this.queue[i].char = char;
                  }
                  output += `<span class="dud">${char}</span>`;
                } else {
                  output += from;
                }
              }
              this.el.innerHTML = output;
              if (complete === this.queue.length) {
                this.resolve();
              } else {
                this.frameRequest = requestAnimationFrame(this.update);
                this.frame++;
              }
            }
            randomChar() {
                return this.chars[Math.floor(Math.random() * this.chars.length)];
            }}
    </script>
    <script>
      const wakeUp = function () {
          let time;

          window.onload = resetTime;
          window.onclick = resetTime;
          window.onkeydown = resetTime;
          window.ontouchstart = resetTime;
          window.onmousemove = resetTime;
          window.onmousedown = resetTime;
          window.addEventListener('scroll', resetTime, true);
          
          const $terminal = $("#terminal");
          const $container = $(".container");

          const $clone = $(".container").clone();

          function wakeUser() {
              $container.hide();
              $clone.html("").attr("class", "").attr("style", "").css({"background-color": "#000", "height": "100%"}).appendTo($terminal);
              const $type = $('<span />');
              $type.addClass('typed-text');
              $type.css("color", "#149414");
              $clone.append($type);

              const typedTextSpan = $type[0];

              const textArray = [
                  "Wake up Neo...",
                  "The Matrix has you...",
                  "Follow the white rabbit.",
                  "Knock knock, Neo."
              ];
              const typingDelay = 200;
              const erasingDelay = 100;
              const newTextDelay = 2000;
              const loopLimit = 1;
              let textArrayIndex = 0;
              let charIndex = 0;
              let loopCount = 0;

              function type() {
                  if (charIndex < textArray[textArrayIndex].length) {
                      typedTextSpan.textContent += textArray[textArrayIndex].charAt(charIndex);
                      charIndex++;
                      setTimeout(type, typingDelay);
                  } else {
                      setTimeout(erase, newTextDelay);
                  }
              }

              function erase() {
                  if (charIndex > 0) {
                      typedTextSpan.textContent = textArray[textArrayIndex].substring(0, charIndex - 1);
                      charIndex--;
                      setTimeout(erase, erasingDelay);
                  } else {
                      textArrayIndex++;
                      if (textArrayIndex >= textArray.length) {
                          textArrayIndex = 0;
                          loopCount++;
                          if (loopCount >= loopLimit) {
                              let options = {
                                  waitTime: 3500,
                                  autoStart: false,
                                  on: {
                                      hideStart: function () {
                                          return;
                                      },
                                  }
                              };
                              const $scsaver = $('<div />');
                              $scsaver.addClass('scsaver');
                              $scsaver.attr("id", "scsaver");
                              $scsaver.css({"margin-top": "-10px"});
                              const $scinner = $('<div />');
                              $scinner.addClass('scsaver-inner');
                              $scsaver.append($scinner);
                              $clone.append($scsaver);
                              const scsaver = new Scsaver('#scsaver', options);
                              scsaver.disabled();
                              const $main = $("<main />");
                              $scinner.append($main);
                              for (let i = 0; i < 50; ++i) {
                                  new Raindrop({container: $main[0], row: 50});
                              }
                              scsaver.enabled();
                              return;
                          }
                      }
                      setTimeout(type, typingDelay + 1100);
                  }
              }

              setTimeout(type, newTextDelay + 250);
          }


          function resetTime() {
              clearTimeout(time);
              time = setTimeout(wakeUser, 1000 * 100);
              $clone.remove();
              $container.show();
              return;
          }
      };

    </script>
    <script type="module">
        import { TerminalEmulator, VirtualFileSystem } from './js/index.js';
        import utils from './js/utils.js';
        import { PythonREPL } from './js/plugins/python.js';
        import { TextEditor } from './js/plugins/edit.js';
        import { GitHubCli } from './js/plugins/github.js';
        import { NodeJS } from './js/plugins/nodejs.js';
        import { NPM } from './js/plugins/npm.js';

        const vfs = new VirtualFileSystem();
        const terminal = new TerminalEmulator('#terminal', vfs, {
            maxHistorySize: 500,
            theme: 'onedark'
        });
        
        terminal.registerCommand("wizard", {
            "name": "wizard",
            "type": "script",
            "mime": "application/javascript",
            "help": "<span class=\"cmd\">wizard</span>: Interactive setup wizard\n\nGuides new users through initial terminal configuration and features.\n\nOptions:\n\t--reset\t\tReset user data and run setup again\n\t--demo\t\tRun in demo mode (no data persistence)\n\t-h, --help\tShow this help message",
            "func": async function (terminal, argv) {
                if (argv.help || argv.h) {
                    terminal.printHTML(terminal.commands[argv.command].help);
                    return;
                }

                // Get user's IP address
                try {
                    const response = await fetch('https://api64.ipify.org?format=json');
                    const data = await response.json();
                    terminal.user.ip = data.ip;
                } catch (error) {
                    console.warn('Failed to retrieve client IP:', error);
                    terminal.user.ip = `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
                }

                const originalPS1 = terminal._promptPS1.innerHTML;
                const isReset = argv.reset;
                const isDemo = argv.demo;
                const isReturningUser = !isDemo && !isReset && terminal.user.name !== "demo";

                const identity =
                    "                                      ┌──┌──┌──┐              \n" +
                    "┌───────┌─────┌─────┌────────┌─────┌──┘  ├──│  └─┌─────┌─────┐\n" +
                    "│       │  ╵──│  └──│        │  ╵──│  ─  │  │   ─│  ─  │  └──┘\n" +
                    "└─┐   ┌─└─────└──┘  └──└──└──└─────└─────└──└────└─────└──┘   \n" +
                    "  │   │                                                       \n" +
                    "  │   │                                                       \n" +
                    "  └───┘                                                         ";
                
                // ASCII Art Header
                const headerArt = [
                    "╔══════════════════════════════════════════════════════════════╗",
                    "║                    TERM[E]DITOR SETUP WIZARD                 ║",
                    "║                         Version 2.0                          ║",
                    "╚══════════════════════════════════════════════════════════════╝"
                ].join('\n');

                // Configuration object to track wizard state
                const wizardConfig = {
                    step: 1,
                    totalSteps: 6,
                    userData: {},
                    settings: {},
                    features: []
                };

                // Utility functions
                const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
                
                const showProgress = (current, total, description) => {
                    const percentage = Math.round((current / total) * 100);
                    const barLength = 30;
                    const filled = Math.round((percentage / 100) * barLength);
                    const empty = barLength - filled;
                    const bar = '█'.repeat(filled) + '[]'.repeat(empty);
                    
                    terminal.printInfo(`[${bar}] ${percentage}% - ${description}`);
                };

                const typeWithDelay = async (text, delay = 30) => {
                    for (const char of text) {
                        await sleep(delay);
                        process.stdout?.write?.(char) || terminal.write(char);
                    }
                };

                const animateText = async (text, className = 'success') => {
                    terminal.printHTML(`<span class="${className}">${text}</span>`);
                    await sleep(500);
                };

                const createFileStructure = () => {
                    try {
                        // Create user directories
                        terminal.vfs.mkdir('/home/demo/Documents');
                        terminal.vfs.mkdir('/home/demo/Downloads'); 
                        terminal.vfs.mkdir('/home/demo/Projects');
                        terminal.vfs.mkdir('/home/demo/.config');
                        
                        // Create welcome file
                        const welcomeContent = `Welcome to TERM[E]DITOR, ${wizardConfig.userData.name}!

        This terminal emulator includes:
        • Full Unix-like command set (ls, cd, cat, mkdir, etc.)
        • Virtual file system with persistence
        • Interactive games and utilities
        • Customizable themes and settings
        • Built-in text editor capabilities

        Try these commands to get started:
        • help - Show available commands
        • ls -la - List files with details
        • tree - Show directory structure
        • theme -l - List available themes
        • blackjack - Play a card game

        Your files are stored in: ${terminal.user.home}

        Happy computing!
        `;
                        terminal.vfs.cat('>', '/home/demo/Documents/README.txt', welcomeContent);
                        
                        // Create sample project
                        terminal.vfs.cat('>', '/home/demo/Projects/hello.js', `console.log('Hello, ${wizardConfig.userData.name}!');`);
                        
                        // Create config file
                        const configContent = JSON.stringify({
                            theme: wizardConfig.settings.theme,
                            fontSize: wizardConfig.settings.fontSize,
                            setupDate: new Date().toISOString(),
                            version: '2.0'
                        }, null, 2);
                        terminal.vfs.cat('>', '/home/demo/.config/terminal.json', configContent);
                        
                    } catch (error) {
                        console.warn('Failed to create file structure:', error);
                    }
                };

                // Main wizard exit function
                const exitWizard = async () => {
                    showProgress(wizardConfig.totalSteps, wizardConfig.totalSteps, "Setup Complete!");
                    await sleep(1000);
                    
                    await animateText("🎉 Welcome to TERM[E]DITOR! 🎉", "success");
                    await sleep(1000);
                    
                    if (!isDemo) {
                        terminal.printInfo('Saving your preferences...');
                        terminal.opts.user = terminal.user;
                        terminal.savePrefs();
                        await sleep(1000);
                    }
                    
                    terminal.printSuccess('✓ Setup completed successfully!');
                    await sleep(1500);
                    
                    terminal.setPrompt(originalPS1);
                    terminal.clear();
                    
                    terminal.printHTML(`<span class="host">TERM[E]DITOR BASH</span>&mdash;v2.0`);
                    terminal.printHTML(`Welcome back, <span class="user">${terminal.user.name}</span>!`);
                    terminal.printHTML(`Type <span class="cmd">help</span> to see available commands.`);
                    terminal.newLine();
                };

                // Step functions
                const step1_Welcome = async () => {
                    terminal.clear();
                    terminal.print(identity);
                    terminal.newLine();
                    
                    showProgress(1, wizardConfig.totalSteps, "Welcome");
                    await sleep(1000);
                    
                    if (isReturningUser) {
                        await animateText(`Welcome back, ${terminal.user.name}!`, "user");
                        await sleep(1000);
                        terminal.printWarn('It looks like you\'ve already completed the setup.');
                        const runAgain = await terminal.confirm('Would you like to run the wizard again?');
                        if (!runAgain) {
                            await exitWizard();
                            return;
                        }
                        terminal.newLine();
                    }
                    
                    await animateText("Welcome to the TERM[E]DITOR Setup Wizard!", "info");
                    await sleep(1000);
                    
                    terminal.printInfo(`Connecting from IP: `).printSuccess(`${terminal.user.ip}`);
                    await sleep(1500);
                    
                    terminal.printInfo('This wizard will help you:');
                    const features = [
                        '• Set up your user profile',
                        '• Configure terminal preferences', 
                        '• Choose your theme',
                        '• Create initial file structure',
                        '• Learn basic commands',
                        '• Set up games and entertainment'
                    ];
                    
                    for (const feature of features) {
                        await sleep(1000);
                        terminal.printInfo(`${feature}`);
                    }
                    
                    await sleep(1000);
                    const proceed = await terminal.confirm('Ready to begin?', true);
                    if (!proceed) {
                        terminal.printError('Setup cancelled.');
                        await exitWizard();
                        return;
                    }
                    
                    wizardConfig.step = 2;
                    await step2_UserInfo();
                };

                const step2_UserInfo = async () => {
                    terminal.clear();
                    terminal.printHTML(headerArt);
                    terminal.newLine();
                    
                    showProgress(2, wizardConfig.totalSteps, "User Information");
                    await sleep(500);
                    
                    await animateText("Let's set up your user profile", "info");
                    terminal.newLine();
                    
                    // Get name
                    const name = await terminal.prompt('What\'s your name?');
                    if (!name.trim()) {
                        terminal.printError('Name cannot be empty!');
                        return await step2_UserInfo();
                    }
                    wizardConfig.userData.name = name.trim();
                    terminal.user.name = name.trim();
                    
                    await animateText(`Hello, ${name}!`, "success");
                    await sleep(1000);
                    
                    // Get email (optional)
                    const email = await terminal.prompt('Email address (optional):');
                    if (email.trim()) {
                        wizardConfig.userData.email = email.trim();
                        terminal.user.email = email.trim();
                    }
                    
                    // Set up security
                    const usePassword = await terminal.confirm('Would you like to set a password for your account?');
                    if (usePassword) {
                        const password = await terminal.password('Enter password:');
                        if (password.trim()) {
                            wizardConfig.userData.hasPassword = true;
                            terminal.user.pass = password;
                            await animateText("Password set successfully", "success");
                        }
                    }
                    
                    // Persistence option
                    if (!isDemo) {
                        const enablePersistence = await terminal.confirm('Enable data persistence? (Remember your settings between sessions)');
                        wizardConfig.userData.persistence = enablePersistence;
                        if (enablePersistence) {
                            await animateText("Persistence enabled - your data will be saved", "success");
                        } else {
                            await animateText("Session-only mode - data won't be saved", "warn");
                        }
                    }
                    
                    wizardConfig.step = 3;
                    await step3_Preferences();
                };

                const step3_Preferences = async () => {
                    terminal.clear();
                    terminal.printHTML(headerArt);
                    terminal.newLine();
                    
                    showProgress(3, wizardConfig.totalSteps, "Preferences");
                    await sleep(500);
                    
                    await animateText("Let's customize your terminal", "info");
                    terminal.newLine();
                    
                    const themes = {
                        "onedark": "One Dark (default)",
                        "dracula": "Dracula",
                        "nord": "Nord", 
                        "nightowl": "Night Owl",
                        "laserwave": "Laser Wave",
                        "greyscale": "Greyscale"
                    };
                    
                    terminal.printInfo('Available themes:');
                    Object.entries(themes).forEach(([key, name], index) => {
                        terminal.printHTML(`  <span class="cmd">${index + 1}</span>. ${name}`);
                    });
                    
                    const themeChoice = await terminal.prompt('Select theme (1-6) [1]:');
                    const themeIndex = parseInt(themeChoice) || 1;
                    const themeKeys = Object.keys(themes);
                    const selectedTheme = themeKeys[themeIndex - 1] || 'onedark';
                    
                    wizardConfig.settings.theme = selectedTheme;
                    terminal.setTheme(selectedTheme);
                    await animateText(`✓ Theme set to: ${themes[selectedTheme]}`, "success");
                    await sleep(1000);
                    
                    const fontSize = await terminal.prompt('Font size (small/medium/large) [medium]:');
                    const fontSizes = {
                        'small': '0.9em',
                        'medium': '1em', 
                        'large': '1.1em'
                    };
                    const selectedSize = fontSizes[fontSize.toLowerCase()] || '1em';
                    wizardConfig.settings.fontSize = selectedSize;
                    terminal.setTextSize(selectedSize);
                    await animateText(`Font size: ${fontSize || 'medium'}`, "success");
                    
                    wizardConfig.step = 4;
                    await step4_FileSystem();
                };

                const step4_FileSystem = async () => {
                    terminal.clear();
                    terminal.printHTML(headerArt);
                    terminal.newLine();
                    
                    showProgress(4, wizardConfig.totalSteps, "File System Setup");
                    await sleep(500);
                    
                    await animateText("Creating your file system", "info");
                    terminal.newLine();
                    
                    const setupFiles = await terminal.confirm('Create standard directories and sample files?', true);
                    if (setupFiles) {
                        terminal.printInfo('Creating directories...');
                        await sleep(1000);
                        
                        const dirs = ['Documents', 'Downloads', 'Projects', '.config'];
                        for (const dir of dirs) {
                            terminal.printSuccess(`Created ${dir}/`);
                            await sleep(300);
                        }
                        
                        createFileStructure();
                        
                        terminal.printInfo('Creating sample files...');
                        await sleep(500);
                        terminal.printSuccess('README.txt');
                        terminal.printSuccess('hello.js');
                        terminal.printSuccess('terminal.json');
                        
                        await animateText("File system ready!", "success");
                    }
                    
                    wizardConfig.step = 5;
                    await step5_Tutorial();
                };

                const step5_Tutorial = async () => {
                    terminal.clear();
                    terminal.printHTML(headerArt);
                    terminal.newLine();
                    
                    showProgress(5, wizardConfig.totalSteps, "Quick Tutorial");
                    await sleep(500);
                    
                    await animateText("Quick command tutorial", "info");
                    terminal.newLine();
                    
                    const runTutorial = await terminal.confirm('Would you like a quick tutorial of basic commands?');
                    if (runTutorial) {
                        const commands = [
                            { cmd: 'pwd', desc: 'Show current directory' },
                            { cmd: 'ls', desc: 'List files and directories' },
                            { cmd: 'cd Documents', desc: 'Change to Documents folder' },
                            { cmd: 'cat README.txt', desc: 'Display file contents' },
                            { cmd: 'tree', desc: 'Show directory structure' },
                            { cmd: 'help', desc: 'Show all available commands' }
                        ];
                        
                        terminal.printInfo('Here are some essential commands to try:');
                        terminal.newLine();
                        
                        for (const {cmd, desc} of commands) {
                            await sleep(800);
                            terminal.printHTML(`  <span class="cmd">${cmd}</span> - ${desc}`);
                        }
                        
                        terminal.newLine();
                        const tryNow = await terminal.confirm('Want to try the "tree" command now?');
                        if (tryNow) {
                            terminal.newLine();
                            await terminal.executeCommand('tree');
                            await sleep(2000);
                            await terminal.pause('Press any key to continue...');
                        }
                    }
                    
                    wizardConfig.step = 6;
                    await step6_Features();
                };

                const step6_Features = async () => {
                    terminal.clear();
                    terminal.printHTML(headerArt);
                    terminal.newLine();
                    
                    showProgress(6, wizardConfig.totalSteps, "Additional Features");
                    await sleep(500);
                    
                    await animateText("🎮 Additional features setup", "info");
                    terminal.newLine();
                    
                    // Gaming setup
                    const enableGaming = await terminal.confirm('Enable gaming features? (Blackjack, etc.)');
                    if (enableGaming) {
                        wizardConfig.features.push('gaming');
                        terminal.user.cash = terminal.user.cash || 1000;
                        await animateText(`✓ Gaming enabled - Starting cash: $${terminal.user.cash}`, "success");
                    }
                    
                    // Developer tools
                    const enableDevTools = await terminal.confirm('Enable developer tools? (Enhanced file editing, etc.)');
                    if (enableDevTools) {
                        wizardConfig.features.push('devtools');
                        await animateText("✓ Developer tools enabled", "success");
                    }
                    
                    // System info
                    const showSysInfo = await terminal.confirm('Show system information?');
                    if (showSysInfo) {
                        terminal.newLine();
                        terminal.printInfo('System Information:');
                        terminal.printHTML(`Platform: ${navigator.platform}`);
                        terminal.printHTML(`User Agent: ${navigator.userAgent.split(' ')[0]}`);
                        terminal.printHTML(`Screen: ${screen.width}x${screen.height}`);
                        terminal.printHTML(`Language: ${navigator.language}`);
                        terminal.printHTML(`Cookies: ${navigator.cookieEnabled ? 'Enabled' : 'Disabled'}`);
                        await sleep(2000);
                    }
                    
                    await exitWizard();
                };

                terminal.secondaryCommand(true);
                terminal.setPrompt(' ');
                await step1_Welcome();
            }
        });
                
        terminal.registerCommand("blackjack", {
            "name": "blackjack",
            "type": "script",
            "mime": "application/javascript",
            "help": "<span class=\"cmd\">blackjack</span>:\n\tLaunch the game Blackjack\n\n\t",
            "func": async function (terminal, argv) {
                if (argv.help || argv.h) {
                    terminal.printHTML(terminal.commands[argv.command].help);
                    return;
                }
                console.log(argv);
                let blackjack = terminal.user.games?.blackjack || {
                    handsPlayed: 0,
                    handsWon: 0,
                    handsLost: 0,
                    handsPushed: 0
                };

                if (!terminal.user.games) {
                    terminal.user.games = {};
                }

                const originalPS1 = terminal._promptPS1.innerHTML;
                
                terminal.secondaryCommand(true);
                terminal.showPrompt = false;
                terminal.setPrompt(' ');
                terminal.newLine();
                
                await terminal.type("Launching Blackjack...");
                terminal.newLine();
                await TerminalEmulator.sleep(1500);
                terminal.write("Loaded!");
                await TerminalEmulator.sleep(1000);
                terminal.clear();

                const init =
                    "╷───────┌──┌───┬─┌────┌──╷──┌──┌───┬─┌────┌──╷──┐\n" +
                    "│   ┌╴  │  │ ┌╴  │  ╶─│    <│  │ ┌╴  │  ╶─│    < \n" +
                    "│       │  └┬──┴─└────└──╵─┬┘  ├───┴─└────└──╵──┘\n" +
                    "│   ┌╴   \\──┘              └───┘                 \n" +
                    "│        /        v2.0 by daemon.devin \n" +
                    "└───────'";

                function createDeck() {
                    const suits = ['♥', '♦', '♣', '♠'];
                    const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                    const deck = [];

                    for (let suit of suits) {
                        for (let value of values) {
                            deck.push({ suit, value });
                        }
                    }
                    return deck;
                }

                // Shuffle deck
                function shuffleDeck(deck) {
                    for (let i = deck.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [deck[i], deck[j]] = [deck[j], deck[i]];
                    }
                }

                // ASCII card rendering
                function renderCards(cards, suits) {
                    //console.table(cards);
                    //console.table(suits);
                    var lines = ["", "", "", "", "", ""];
                    var value = [];
                    if (cards.length == 1) { //if only one card is passed we draw the first card face down
                        lines = [
                            "┌───────┐",
                            "│  ───  │",
                            "│ ───── │",
                            "│ ───── │",
                            "│  ───  │",
                            "└───────┘"
                        ];
                    }
                    //topline
                    for (let i = 0; i < cards.length; i++) {
                        lines[0] += "┌───────┐";
                    }
                    lines[0] += "\n";

                    //2nd line (contains value)
                    for (let i = 0; i < cards.length; i++) {
                        lines[1] += "│" + cards[i];
                        if (cards[i] == 10) {
                            lines[1] += " ──. │";
                        } else {
                            lines[1] += " ───. │";
                        }
                    }
                    lines[1] += "\n";

                    //3rd line (contains suit)
                    for (let i = 0; i < cards.length; i++) {

                        lines[2] += "│ ¦ " + suits[i] + " ¦ │";
                    }
                    lines[2] += "\n";

                    //4th line (contains suit)
                    for (let i = 0; i < cards.length; i++) {

                        lines[3] += "│ ¦ " + suits[i] + " ¦ │";
                    }
                    lines[3] += "\n";

                    //4th line (contains value)
                    for (let i = 0; i < cards.length; i++) {
                        if (cards[i] == 10) {
                            lines[4] += "│ '── " + cards[i] + "│";
                        } else {
                            lines[4] += "│ '─── " + cards[i] + "│";
                        }

                    }
                    lines[4] += "\n";

                    //bottom line
                    for (let i = 0; i < cards.length; i++) {
                        lines[5] += "└───────┘";
                    }
                    lines[5] += "\n";
                    return lines[0] + lines[1] + lines[2] + lines[3] + lines[4] + lines[5];
                }
                // Calculate hand value
                function calculateHand(hand) {
                    let sum = 0;
                    let hasAce = false;

                    for (let card of hand) {
                        if (card.value === 'A') {
                            hasAce = true;
                            sum += 11;
                        } else if (['K', 'Q', 'J'].includes(card.value)) {
                            sum += 10;
                        } else {
                            sum += parseInt(card.value);
                        }
                    }

                    // Adjust for aces
                    if (hasAce && sum > 21) {
                        sum -= 10;
                    }

                    return sum;
                }

                // Check if hand is bust
                function bust(handValue) {
                    return handValue > 21;
                }

                // Quit game function
                async function quit() {
                    terminal.setPrompt(' ');
                    terminal.newLine();
                    terminal.print("Cleaning up the cards and saving statistics..");
                    
                    terminal.user.games.blackjack = blackjack;
                    terminal.opts.user = terminal.user;
                    if (terminal.savePrefs) {
                        terminal.savePrefs();
                    }
                    
                    await TerminalEmulator.sleep(1500);
                    await terminal.type("Thanks for playing!");
                    await TerminalEmulator.sleep(1500);
                    terminal.clear();
                    terminal.setPrompt(originalPS1);
                    terminal.showPrompt = true;
                    terminal.secondaryCommand(false);
                    return;
                }

                // Play again prompt
                async function dealAgain() {
                    terminal.newLine().printHTML(`You've got <span class="success">$${terminal.user.cash}</span> in your account..`);
                    terminal.setPrompt('> ');
                    const again = await terminal.confirm("Want to play again?", true);
                    if (again) {
                        await startGame();
                    } else {
                        await quit();
                    }
                }

                // Main game function
                async function startGame() {
                    blackjack.handsPlayed++;
                    terminal.clear();
                    terminal.print(init);
                    terminal.printHTML(`You've got <span class="success">$${terminal.user.cash}</span> in your account.`);
                    terminal.newLine();

                    // Show placeholder cards
                    const placeholderCards = renderCards(["?", "?"], ["?", "?"]);

                    const cards = 
                    "┌───────┐┌───────┐\n" +
                    "│  ───  ││  ───  │\n" +
                    "│ ───── ││ ───── │\n" +
                    "│ ───── ││ ───── │\n" +
                    "│  ───  ││  ───  │\n" +
                    "└───────┘└───────┘\n";
                    
                    await terminal
                        .setPrompt(' ')
                        .newLine()
                        .write("Dealer's Cards:")
                        .newLine()
                        .type(cards, 1);

                    await terminal
                        .write("Your Cards:")
                        .newLine()
                        .type(cards, 1);

                    terminal.newLine().setPrompt('> ');

                    // Get wager
                    let wagerInput = await terminal.prompt("What's your wager? [20] ", true);
                    let wager = parseInt(wagerInput) || 20;
                    
                    if (wager > terminal.user.cash) {
                        terminal.printHTML("<span class=\"error\">You don't have enough money!</span>");
                        terminal.newLine();
                        await terminal.pause("Press any key to quit!", true);
                        await quit();
                        return;
                    }

                    terminal.setPrompt(' ').clear();
                    terminal.print(init);

                    // Create and shuffle deck
                    let deck = createDeck();
                    shuffleDeck(deck);

                    const playersHand = [];
                    const dealersHand = [];
                    const playerCards = [];
                    const dealerCards = [];
                    const playerSuits = [];
                    const dealerSuits = [];

                    const drawCard = (player) => {
                        let card = deck.pop();
                        if (player === 0) {
                            dealerCards.push(card.value);
                            dealerSuits.push(card.suit);
                            dealersHand.push(card);
                        } else {
                            playerCards.push(card.value);
                            playerSuits.push(card.suit);
                            playersHand.push(card);
                        }
                    };

                    drawCard(0);
                    drawCard(0);            
                    drawCard(1);
                    drawCard(1);

                    let playerHandValue = calculateHand(playersHand);
                    let dealerHandValue = calculateHand(dealersHand);

                    let passcards, passsuits;
                    if (dealerCards.length > 1) {
                        passcards = dealerCards.slice(1, 2);
                        passsuits = dealerSuits.slice(1, 2);
                    }

                    await terminal
                        .write('Dealer\'s hand:')
                        .newLine();
                    await terminal.type(renderCards(passcards, dealerSuits), 1);

                    await TerminalEmulator.sleep(500);
                    terminal.printHTML("Dealer's score: <span class=\"info\">--</span>");
                    terminal.newLine();

                    await terminal
                        .write('Your hand:')
                        .newLine();
                    await terminal.type(renderCards(playerCards, playerSuits), 1);

                    await TerminalEmulator.sleep(500);
                    terminal.printHTML(`Your score: <span class="info">${playerHandValue}</span>`);
                    
                    // Check for natural blackjack
                    if (playerHandValue === 21) {
                        terminal.printHTML("<span class=\"success\">Blackjack!</span>");
                        await TerminalEmulator.sleep(1000);
                        
                        // Reveal dealer's hand
                        await showFinalHands(playersHand, dealersHand, playerHandValue, dealerHandValue);
                        
                        if (dealerHandValue === 21) {
                            terminal.printHTML("Dealer also has blackjack - it's a push!");
                            blackjack.handsPushed++;
                        } else {
                            terminal.printHTML("You win with a natural blackjack!");
                            blackjack.handsWon++;
                            terminal.user.cash += Math.floor(wager * 1.5); // Blackjack pays 3:2
                        }
                        
                        await TerminalEmulator.sleep(1500);
                        await dealAgain();
                        return;
                    }

                    // Player's turn
                    terminal.setPrompt('> ');
                    while (await terminal.confirm('Would you like to hit?')) {
                        playersHand.push(deck.pop());
                        playerHandValue = calculateHand(playersHand);

                        terminal.setPrompt(' ').clear();
                        terminal.print(init);

                        await terminal.write('Dealer\'s hand:').newLine();
                        await terminal.type(renderCards(passcards, dealerSuits), 1);
                        await TerminalEmulator.sleep(500);
                        terminal.printHTML("Dealer's score: <span class=\"info\">??</span>");
                        terminal.newLine();

                        await terminal.write('Your hand:').newLine();
                        const updatedCards = playersHand.map(c => c.value);
                        const updatedSuits = playersHand.map(c => c.suit);
                        await terminal.type(renderCards(updatedCards, updatedSuits), 5);
                        
                        await TerminalEmulator.sleep(500);
                        terminal.printHTML(`Your score: <span class="info">${playerHandValue}</span>`);
                        terminal.newLine();

                        if (bust(playerHandValue)) {
                            await TerminalEmulator.sleep(1500);
                            terminal.printError('Bust! You lose.');
                            blackjack.handsLost++;
                            terminal.user.cash -= wager;
                            await TerminalEmulator.sleep(1500);
                            await dealAgain();
                            return;
                        }
                        terminal.setPrompt('> ');
                    }
                    terminal.setPrompt(' ');
                    await TerminalEmulator.sleep(500);

                    // Dealer's turn
                    if (!bust(playerHandValue)) {
                        while (dealerHandValue < 17) {
                            await TerminalEmulator.sleep(500);
                            terminal.print('Dealer hits!');
                            dealersHand.push(deck.pop());
                            dealerHandValue = calculateHand(dealersHand);
                        }
                    }

                    // Show final results
                    await showFinalHands(playersHand, dealersHand, playerHandValue, dealerHandValue);

                    // Determine winner
                    if (bust(dealerHandValue) && !bust(playerHandValue)) {
                        await terminal.type('Dealer busts! You win!');
                        blackjack.handsWon++;
                        terminal.newLine().printSuccess(`$${wager}`).write(' was added to your account!');
                        terminal.user.cash += wager;
                    } else if (bust(playerHandValue)) {
                        await terminal.type('You bust! Dealer wins.');
                        blackjack.handsLost++;
                        terminal.newLine().printError(`$${wager}`).write(' was deducted from your account!');
                        terminal.user.cash -= wager;
                    } else if (playerHandValue > dealerHandValue) {
                        await terminal.type('You win!');
                        blackjack.handsWon++;
                        terminal.newLine().printSuccuss(`$${wager}`).write(' was added to your account!');
                        terminal.user.cash += wager;
                    } else if (playerHandValue < dealerHandValue) {
                        await terminal.type('You lose.');
                        blackjack.handsLost++;
                        terminal.newLine().printError(`$${wager}`).write(' was deducted from your account!');
                        terminal.user.cash -= wager;
                    } else {
                        await terminal.type('It\'s a tie!');
                        blackjack.handsPushed++;
                        terminal.newLine().printHTML(`You still have <span class="success">$${terminal.user.cash}</span> in your account..`);
                    }

                    await TerminalEmulator.sleep(1500);
                    await dealAgain();
                }

                // Show final hands function
                async function showFinalHands(playersHand, dealersHand, playerHandValue, dealerHandValue) {
                    terminal.clear();
                    terminal.print(init);

                    await terminal.write('Dealer\'s hand:').newLine();
                    const dealerCards = dealersHand.map(c => c.value);
                    const dealerSuits = dealersHand.map(c => c.suit);
                    await terminal.print(renderCards(dealerCards, dealerSuits));

                    await TerminalEmulator.sleep(500);
                    terminal.printHTML(`Dealer's score: <span class="info">${dealerHandValue}</span>`);
                    terminal.newLine();

                    await terminal.write('Your hand:').newLine();
                    const playerCards = playersHand.map(c => c.value);
                    const playerSuits = playersHand.map(c => c.suit);
                    terminal.print(renderCards(playerCards, playerSuits));

                    await TerminalEmulator.sleep(500);
                    terminal.printHTML(`Your score: <span class="info">${playerHandValue}</span>`);
                    terminal.newLine();
                }

                // Start the game
                terminal.print(init);
                terminal.printHTML(`Welcome to the Blackjack table <span class="user">${terminal.user.name}</span>!`);
                await TerminalEmulator.sleep(1500);
                terminal.newLine();

                terminal.newLine().setPrompt('> ');
                const deal = await terminal.confirm('Shall I deal the cards?', true);
                terminal.newLine();

                if (deal) {
                    await startGame();
                } else {
                    await quit();
                }
            }
        });

        terminal.registerCommand("rps", {
            "name": "rps",
            "type": "script",
            "mime": "application/javascript",
            "help": "<span class=\"cmd\">rps</span>: Rock Paper Scissors game\n\tPlay the classic game against the computer\n\n\t",
            "func": async function (terminal, argv) {
                if (argv.help || argv.h) {
                    terminal.printHTML(terminal.commands[argv.command].help);
                    return;
                }

                // Initialize game stats
                let rps = terminal.user.games?.rps || {
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0,
                    ties: 0
                };

                if (!terminal.user.games) {
                    terminal.user.games = {};
                }

                const originalPS1 = terminal._promptPS1.innerHTML;
                terminal.secondaryCommand(true);
                terminal.setPrompt(' ');

                const gameArt = [
                    "╔═══════════════════════════════════════╗",
                    "║      ROCK  •  PAPER  •  SCISSORS      ║",
                    "╚═══════════════════════════════════════╝"
                ].join('\n');

                const choices = ['rock', 'paper', 'scissors'];
                const emojis = {
                    rock: '🪨',
                    paper: '📄',
                    scissors: '✂️'
                };

                const asciiArt = {
                    rock: [
                        "    _______",
                        "---'   ____)",
                        "      (_____)",
                        "      (_____)",
                        "      (____)",
                        "---.__(___)"
                    ],
                    paper: [
                        "     _______",
                        "---'    ____)____",
                        "           ______)",
                        "          _______)",
                        "         _______)",
                        "---.__________)"
                    ],
                    scissors: [
                        "    _______",
                        "---'   ____)____",
                        "          ______)",
                        "       __________)",
                        "      (____)",
                        "---.__(___)"
                    ]
                };

                async function quit() {
                    terminal.user.games.rps = rps;
                    terminal.opts.user = terminal.user;
                    if (terminal.savePrefs) terminal.savePrefs();
                    
                    terminal.printInfo(`Final Stats: ${rps.wins}W-${rps.losses}L-${rps.ties}T`);
                    await TerminalEmulator.sleep(1500);
                    
                    terminal.setPrompt(originalPS1);
                    terminal.showPrompt = true;
                    terminal.secondaryCommand(false);
                }

                async function playRound() {
                    terminal.clear();
                    terminal.print(gameArt);
                    terminal.printInfo(`Stats: ${rps.wins}W-${rps.losses}L-${rps.ties}T`);
                    terminal.newLine();

                    terminal.setPrompt('> ');
                    const playerChoice = await terminal.prompt('Choose (rock/paper/scissors) or "quit":');
                    
                    if (playerChoice.toLowerCase() === 'quit') {
                        await quit();
                        return;
                    }

                    if (!choices.includes(playerChoice.toLowerCase())) {
                        terminal.printError('Invalid choice! Try again.');
                        await TerminalEmulator.sleep(1000);
                        return await playRound();
                    }

                    const player = playerChoice.toLowerCase();
                    const computer = choices[Math.floor(Math.random() * 3)];

                    rps.gamesPlayed++;

                    terminal.clear();
                    terminal.print(gameArt);
                    
                    await terminal.type("3...", 250);
                    await terminal.type("2...", 250);
                    await terminal.type("1...", 250);
                    await terminal.type("SHOOT!", 200);
                    terminal.newLine();

                    terminal.printHTML(`<span class="user">You chose: ${emojis[player]} ${player.toUpperCase()}</span>`);
                    terminal.print(asciiArt[player].join('\n'));
                    terminal.newLine();

                    terminal.printHTML(`<span class="host">Computer chose: ${emojis[computer]} ${computer.toUpperCase()}</span>`);
                    terminal.print(asciiArt[computer].join('\n'));
                    terminal.newLine();

                    let result;
                    if (player === computer) {
                        result = "It's a tie!";
                        rps.ties++;
                        terminal.printWarn(`${result}`);
                    } else if (
                        (player === 'rock' && computer === 'scissors') ||
                        (player === 'paper' && computer === 'rock') ||
                        (player === 'scissors' && computer === 'paper')
                    ) {
                        result = "You win!";
                        rps.wins++;
                        const reward = Math.floor(Math.random() * 50) + 10;
                        terminal.user.cash += reward;
                        terminal.printSuccess(`${result}`);
                        terminal.printSuccess(`+$${reward} bonus!`);
                    } else {
                        result = "Computer wins!";
                        rps.losses++;
                        terminal.printError(`${result}`);
                    }

                    await TerminalEmulator.sleep(2000);
                    
                    const playAgain = await terminal.confirm('Play again?');
                    if (playAgain) {
                        await playRound();
                    } else {
                        await quit();
                    }
                }

                terminal.clear();
                terminal.print(gameArt);
                terminal.printInfo(`Welcome to Rock Paper Scissors, ${terminal.user.name}!`);
                await TerminalEmulator.sleep(1000);
                
                const start = await terminal.confirm('Ready to play?');
                if (start) {
                    await playRound();
                } else {
                    await quit();
                }
            }
        });

        terminal.registerCommand("guess", {
            "name": "guess",
            "type": "script", 
            "mime": "application/javascript",
            "help": "<span class=\"cmd\">guess</span>: Number guessing game\n\tGuess the secret number between 1 and 100\n\n\t",
            "func": async function (terminal, argv) {
                if (argv.help || argv.h) {
                    terminal.printHTML(terminal.commands[argv.command].help);
                    return;
                }

                let guess = terminal.user.games?.guess || {
                    gamesPlayed: 0,
                    totalGuesses: 0,
                    bestScore: Infinity,
                    averageGuesses: 0
                };

                if (!terminal.user.games) {
                    terminal.user.games = {};
                }

                const originalPS1 = terminal._promptPS1.innerHTML;
                terminal.secondaryCommand(true);
                terminal.setPrompt(' ');

                const gameArt = [
                    "╔════════════════════════════════════════╗",
                    "║          GUESS THE NUMBER              ║",
                    "║              1 - 100                   ║",
                    "╚════════════════════════════════════════╝"
                ].join('\n');

                async function quit() {
                    terminal.user.games.guess = guess;
                    terminal.opts.user = terminal.user;
                    if (terminal.savePrefs) terminal.savePrefs();

                    if (guess.gamesPlayed > 0) {
                        terminal.printInfo(`Games played: ${guess.gamesPlayed}`);
                        terminal.printInfo(`Best score: ${guess.bestScore === Infinity ? 'N/A' : guess.bestScore} guesses`);
                        terminal.printInfo(`Average guesses: ${guess.averageGuesses.toFixed(1)}`);
                    }
                    
                    await TerminalEmulator.sleep(2000);
                    terminal.setPrompt(originalPS1);
                    terminal.showPrompt = true;
                    terminal.secondaryCommand(false);
                }

                async function playGame() {
                    const secretNumber = Math.floor(Math.random() * 100) + 1;
                    let guesses = 0;
                    let gameOver = false;
                    const maxGuesses = 10;
                    const guessHistory = [];

                    terminal.clear();
                    terminal.print(gameArt);
                    terminal.printInfo(`I'm thinking of a number between 1 and 100...`);
                    terminal.printInfo(`You have ${maxGuesses} guesses. Good luck!`);
                    terminal.newLine();

                    while (!gameOver && guesses < maxGuesses) {
                        terminal.setPrompt(`Guess #${guesses + 1}: `);
                        const input = await terminal.prompt('');
                        const playerGuess = parseInt(input);

                        if (isNaN(playerGuess) || playerGuess < 1 || playerGuess > 100) {
                            terminal.printError('Please enter a number between 1 and 100!');
                            continue;
                        }

                        guesses++;
                        guessHistory.push(playerGuess);

                        if (playerGuess === secretNumber) {
                            gameOver = true;
                            guess.gamesPlayed++;
                            guess.totalGuesses += guesses;
                            guess.averageGuesses = guess.totalGuesses / guess.gamesPlayed;
                            
                            if (guesses < guess.bestScore) {
                                guess.bestScore = guesses;
                                terminal.printSuccess(`CORRECT! New personal best!`);
                            } else {
                                terminal.printSuccess(`CORRECT!`);
                            }

                            terminal.printInfo(`You guessed ${secretNumber} in ${guesses} tries!`);
                            
                            const bonus = Math.max(100 - (guesses * 10), 10);
                            terminal.user.cash += bonus;
                            terminal.printSuccess(`+$${bonus} bonus!`);

                        } else if (playerGuess < secretNumber) {
                            terminal.printWarn(`Too low! Try higher.`);
                            if (guesses === maxGuesses) {
                                terminal.printError(`Game Over! The number was ${secretNumber}.`);
                                guess.gamesPlayed++;
                                guess.totalGuesses += guesses;
                                guess.averageGuesses = guess.totalGuesses / guess.gamesPlayed;
                            }
                        } else {
                            terminal.printWarn(`Too high! Try lower.`);
                            if (guesses === maxGuesses) {
                                terminal.printError(`Game Over! The number was ${secretNumber}.`);
                                guess.gamesPlayed++;
                                guess.totalGuesses += guesses;
                                guess.averageGuesses = guess.totalGuesses / guess.gamesPlayed;
                            }
                        }

                        // Show remaining guesses
                        if (!gameOver && guesses < maxGuesses) {
                            terminal.printInfo(`Guesses remaining: ${maxGuesses - guesses}`);
                            terminal.printInfo(`Previous guesses: ${guessHistory.join(', ')}`);
                        }
                        terminal.newLine();
                    }

                    await TerminalEmulator.sleep(2000);
                    
                    const playAgain = await terminal.confirm('Play again?');
                    if (playAgain) {
                        await playGame();
                    } else {
                        await quit();
                    }
                }

                terminal.clear();
                terminal.print(gameArt);
                terminal.printInfo(`Welcome to Guess the Number, ${terminal.user.name}!`);
                
                if (guess.gamesPlayed > 0) {
                    terminal.printInfo(`Your best: ${guess.bestScore} guesses`);
                }
                
                await TerminalEmulator.sleep(1000);
                
                const start = await terminal.confirm('Ready to play?');
                if (start) {
                    await playGame();
                } else {
                    await quit();
                }
            }
        });

        terminal.registerCommand("slots", {
            "name": "slots",
            "type": "script",
            "mime": "application/javascript", 
            "help": "<span class=\"cmd\">slots</span>: Advanced 5-reel slot machine\n\tMultiple paylines, bonus features, and progressive gameplay!\n\n\t",
            "func": async function (terminal, argv) {
                if (argv.help || argv.h) {
                    terminal.printHTML(terminal.commands[argv.command].help);
                    return;
                }

                let slots = terminal.user.games?.slots || {
                    spins: 0,
                    wins: 0,
                    totalWinnings: 0,
                    biggestWin: 0,
                    jackpots: 0,
                    level: 1,
                    experience: 0
                };

                if (!terminal.user.games) {
                    terminal.user.games = {};
                }

                const originalPS1 = terminal._promptPS1.innerHTML;
                terminal.secondaryCommand(true);
                terminal.showPrompt = false;
                terminal.setPrompt(' ');

                const gameArt = [
                    "╔══════════════════════════════════════════════╗",
                    "║               MEGA SLOTS DELUXE              ║",
                    "║               5 Reels • 9 Lines              ║",
                    "║               v2 - daemon.devin              ║",
                    "╚══════════════════════════════════════════════╝"
                ].join('\n');

                const symbols = ['1', '2', '3', 'A', 'B', 'C', 'X', 'Y', 'Z', 's'];
                const symbolDisplay = {
                    '1': '<span style="color: lightgreen">1</span>',
                    '2': '<span style="color: indianred">2</span>', 
                    '3': '<span style="color: lightblue">3</span>',
                    'A': '<span style="color: green">A</span>',
                    'B': '<span style="color: red">B</span>',
                    'C': '<span style="color: blue">C</span>',
                    'X': '<span style="color: orange">X</span>',
                    'Y': '<span style="color: purple">Y</span>',
                    'Z': '<span style="color: cyan">Z</span>',
                    's': '<span style="color: gold">*</span>'
                };

                // Weighted symbol probabilities (lower index = higher chance)
                const symbolWeights = [15, 12, 10, 8, 6, 4, 3, 2, 1, 1]; // Star is rarest
                
                // Payouts for matching symbols (multiplier per bet)
                const payouts = {
                    '1': [1, 3, 4, 5],      // 2, 3, 4, 5 in a row
                    '2': [2, 6, 8, 10],
                    '3': [3, 9, 12, 15],
                    'A': [5, 15, 20, 25],
                    'B': [10, 30, 40, 50],
                    'C': [15, 45, 60, 75],
                    'X': [30, 90, 120, 150],
                    'Y': [45, 135, 180, 225],
                    'Z': [60, 180, 240, 300],
                    's': [100, 300, 400, 500] // JACKPOT SYMBOL!
                };

                // Payline definitions (row positions for 5 reels)
                const paylines = [
                    [1, 1, 1, 1, 1], // Top row
                    [2, 2, 2, 2, 2], // Middle row  
                    [3, 3, 3, 3, 3], // Bottom row
                    [3, 2, 1, 2, 3], // V up
                    [1, 2, 3, 2, 1], // V down
                    [2, 1, 2, 3, 2], // Up-down
                    [2, 3, 2, 1, 2], // Down-up
                    [1, 1, 2, 3, 3], // Backslash
                    [3, 3, 2, 1, 1]  // Forward slash
                ];

                const cost = 10;
                let reels = [[], [], [], [], []]; // 5 reels, 3 visible symbols each
                let winningLines = [];
                let totalWinnings = 0;

                function getWeightedSymbol() {
                    const totalWeight = symbolWeights.reduce((a, b) => a + b, 0);
                    let random = Math.random() * totalWeight;
                    
                    for (let i = 0; i < symbols.length; i++) {
                        random -= symbolWeights[i];
                        if (random <= 0) {
                            return symbols[i];
                        }
                    }
                    return symbols[0]; // Fallback
                }

                function generateReels() {
                    for (let reel = 0; reel < 5; reel++) {
                        reels[reel] = [];
                        for (let row = 0; row < 3; row++) {
                            reels[reel].push(getWeightedSymbol());
                        }
                    }
                }

                function displayReels(animate = false, frame = 0) {
                    const lines = [];
                    
                    // Top border
                    lines.push('┌───┬───┬───┬───┬───┐');
                    
                    // Three rows of symbols
                    for (let row = 0; row < 3; row++) {
                        let line = '│';
                        for (let reel = 0; reel < 5; reel++) {
                            const symbol = animate ? 
                                symbols[Math.floor(Math.random() * symbols.length)] : 
                                reels[reel][row];
                            const display = animate ? symbol : symbolDisplay[symbol];
                            line += ` ${display.padEnd(1)} │`;
                        }
                        lines.push(line);
                        
                        // Add separator between rows (except after last row)
                        if (row < 2) {
                            lines.push('├───┼───┼───┼───┼───┤');
                        }
                    }
                    
                    // Bottom border
                    lines.push('└───┴───┴───┴───┴───┘');
                    
                    return lines;
                }

                async function animateSlots() {
                    const spinDuration = 15; // frames
                    
                    for (let frame = 0; frame < spinDuration; frame++) {
                        terminal.clear();
                        terminal.print(gameArt);
                        terminal.printInfo(`Balance: ${terminal.user.cash} | Bet: ${cost}`);
                        terminal.newLine();
                        
                        const display = displayReels(true, frame);
                        display.forEach(line => terminal.printHTML(line));
                        
                        await TerminalEmulator.sleep(80 - (frame * 2));
                    }
                    
                    terminal.clear();
                    terminal.print(gameArt);
                    terminal.printInfo(`Balance: ${terminal.user.cash} | Bet: ${cost}`);
                    terminal.newLine();
                    
                    const finalDisplay = displayReels(false);
                    finalDisplay.forEach(line => terminal.printHTML(line));
                }

                function checkPaylines() {
                    winningLines = [];
                    totalWinnings = 0;
                    
                    paylines.forEach((line, lineIndex) => {
                        const symbols = [];
                        for (let reel = 0; reel < 5; reel++) {
                            const row = line[reel] - 1;
                            symbols.push(reels[reel][row]);
                        }

                        let matchCount = 1;
                        const firstSymbol = symbols[0];
                        
                        for (let i = 1; i < symbols.length; i++) {
                            if (symbols[i] === firstSymbol) {
                                matchCount++;
                            } else {
                                break;
                            }
                        }
                        
                        if (matchCount >= 2 && payouts[firstSymbol]) {
                            const payout = payouts[firstSymbol][matchCount - 2] * cost;
                            winningLines.push({
                                line: lineIndex,
                                symbol: firstSymbol,
                                count: matchCount,
                                payout: payout,
                                positions: line
                            });
                            totalWinnings += payout;
                        }
                    });
                    
                    return winningLines.length > 0;
                }

                function displayWinningLines() {
                    if (winningLines.length === 0) return;
                    
                    terminal.newLine();
                    terminal.printSuccess('WINNING LINES!');
                    
                    winningLines.forEach((win, index) => {
                        const symbolName = win.symbol === 's' ? 'STAR' : win.symbol;
                        terminal.printSuccess(`Line ${win.line + 1}: ${win.count}x ${symbolName} = ${win.payout}`);
                    });
                    
                    if (winningLines.some(w => w.symbol === 's')) {
                        terminal.printSuccess('JACKPOT SYMBOLS!');
                        slots.jackpots++;
                    }
                }

                async function spin() {
                    if (terminal.user.cash < cost) {
                        terminal.printError('Insufficient funds!');
                        return false;
                    }
                    
                    slots.spins++;
                    terminal.user.cash -= cost;
                    
                    generateReels();
                    
                    await animateSlots();
                    
                    const hasWin = checkPaylines();
                    
                    if (hasWin) {
                        displayWinningLines();
                        slots.wins++;
                        slots.totalWinnings += totalWinnings;
                        terminal.user.cash += totalWinnings;
                        
                        if (totalWinnings > slots.biggestWin) {
                            slots.biggestWin = totalWinnings;
                        }
                        
                        slots.experience += Math.floor(totalWinnings / 10);
                        if (slots.experience >= slots.level * 100) {
                            slots.level++;
                            terminal.printSuccess(`LEVEL UP! Now level ${slots.level}!`);
                        }
                        
                        terminal.printSuccess(`Total Win: ${totalWinnings}`);
                    } else {
                        terminal.printError('No winning combinations.');
                    }
                    
                    terminal.printInfo(`New Balance: ${terminal.user.cash}`);
                    return true;
                }

                async function quit() {
                    terminal.user.games.slots = slots;
                    terminal.opts.user = terminal.user;
                    if (terminal.savePrefs) terminal.savePrefs();

                    if (slots.spins > 0) {
                        const winRate = ((slots.wins / slots.spins) * 100).toFixed(1);
                        terminal.printInfo(`╔═══════════════════════════════════════╗`);
                        terminal.printInfo(`║              FINAL STATS              ║`);
                        terminal.printInfo(`╚═══════════════════════════════════════╝`);
                        terminal.printInfo(`Level: ${slots.level.toString().padEnd(30)}`);
                        terminal.printInfo(`Experience: ${slots.experience.toString().padEnd(25)}`);
                        terminal.printInfo(`Spins: ${slots.spins.toString().padEnd(30)}`);
                        terminal.printInfo(`Wins: ${slots.wins.toString().padEnd(31)}`);
                        terminal.printInfo(`Win Rate: ${winRate}%${(' ').repeat(24)}`);
                        terminal.printInfo(`Total Winnings: ${slots.totalWinnings.toString().padEnd(18)}`);
                        terminal.printInfo(`Biggest Win: ${slots.biggestWin.toString().padEnd(20)}`);
                        terminal.printInfo(`Jackpots: ${slots.jackpots.toString().padEnd(26)}`);
                    }
                    
                    await TerminalEmulator.sleep(3000);
                    terminal.setPrompt(originalPS1);
                    terminal.secondaryCommand(false);
                }

                async function playSlots() {
                    while (true) {
                        terminal.clear();
                        terminal.print(gameArt);
                        
                        // Show current stats
                        terminal.printInfo(`Level: ${slots.level} | XP: ${slots.experience}/${slots.level * 100}`);
                        terminal.printInfo(`Balance: ${terminal.user.cash} | Cost per spin: ${cost}`);
                        terminal.newLine();
                        
                        // Show paytable for current level
                        terminal.printInfo('PAYTABLE (2+ symbols from left):');
                        Object.entries(payouts).forEach(([symbol, values]) => {
                            const display = symbolDisplay[symbol];
                            const line = values.map((v, i) => `${i+2}x=${v*cost}`).join(' ');
                            terminal.printInfo(`${display}: ${line}`);
                        });
                        terminal.newLine();
                        
                        if (terminal.user.cash < cost) {
                            terminal.printError('Not enough money to play!');
                            await TerminalEmulator.sleep(2000);
                            break;
                        }
                        
                        const action = await terminal.prompt('(S)pin, (Q)uit, or (H)elp: ');
                        
                        switch (action.toLowerCase()) {
                            case 's':
                            case 'spin':
                                await spin();
                                await terminal.pause('Press any key to continue...');
                                break;
                                
                            case 'h':
                            case 'help':
                                terminal.printInfo('MEGA SLOTS HELP');
                                terminal.printInfo('• Match 2+ symbols from left to win');
                                terminal.printInfo('• 9 different paylines active');
                                terminal.printInfo('• * symbols give the biggest payouts');
                                terminal.printInfo('• Gain XP and levels for bigger multipliers');
                                await terminal.pause('Press any key to continue...');
                                break;
                                
                            case 'q':
                            case 'quit':
                                await quit();
                                return;
                                
                            default:
                                terminal.printError('Invalid option!');
                                await TerminalEmulator.sleep(1000);
                        }
                    }
                    
                    await quit();
                }

                // Initialize and start game
                terminal.clear();
                terminal.print(gameArt);
                terminal.printInfo(`Welcome to Mega Slots Deluxe, ${terminal.user.name}!`);
                terminal.printInfo(`Current balance: ${terminal.user.cash}`);
                
                if (slots.spins > 0) {
                    terminal.printInfo(`Your Level: ${slots.level} | Total Spins: ${slots.spins}`);
                }
                
                await TerminalEmulator.sleep(1000);
                
                const start = await terminal.confirm('Ready to spin?');
                if (start) {
                    await playSlots();
                } else {
                    await quit();
                }
            }
        });

        terminal.registerCommand("hacksploit", {
            "name": "hacksploit",
            "type": "script",
            "mime": "application/javascript",
            "help": "<span class=\"cmd\">hacksploit</span>:\n\tLaunch the Hacksploit framework\n\n\tDepending on the target, this command will scan penetration frameworks\n\tto download applicable exploits, payloads, and other various modules.\n\n\tIt will check the host for vulnerabilities, run the modules against the\n\ttarget, execute the payload(s) upon connection, then exports any hash\n\tand/or password dumps to the local filesystem.\n\n\t<span class=\"info\">ATTN: Just a simulation. This is a fake command..</span>\n\n",
            "func": async function (terminal, argv) {
                console.log(argv);
                if (argv.help || argv.h) {
                    terminal.printHTML(terminal.commands[argv.command].help);
                    return;
                }
                const originalPS1 = terminal._promptPS1.innerHTML;
                let $hackData;
                if (argv._.length === 0) {
                    terminal.secondaryCommand(true);
                    terminal.setPrompt(' ').newLine();
                    terminal.showPrompt = false;
                    terminal.command = '';
                    terminal.clear();
                    await terminal.type("Launching Hacksploit..");
                    await TerminalEmulator.sleep(1500);
                    const loading = [
                        'Now loading',
                        'Please wait',
                        'Now loading..',
                        'Please wait..',
                        'Now loading...',
                        'Please wait...'
                    ];
                    const init =
                        "                      :::!~!!!!!:.\n" +
                        "                  .xUHWH!! !!?M88WHX:.\n" +
                        "                .X*#M@$!!  !X!M$$$$$$WWx:.\n" +
                        "               :!!!!!!?H! :!$!$$$$$$$$$$8X:\n" +
                        "              !!~  ~:~!! :~!$!#$$$$$$$$$$8X:\n" +
                        "             :!~::!H!<   ~.U$X!?R$$$$$$$$MM!\n" +
                        "             ~!~!!!!~~ .:XW$$$U!!?$$$$$$RMM!\n" +
                        "             !:~~~~~~ .:ᴅᴀᴇᴍᴏɴ!$WX??#MRRMMM!\n" +
                        "               ~?WuxiW*`   `'#$ᴉɹᴉɥɐꓕ!!??!!!\n" +
                        "             :X- M$$$$       `'T#$T~!8$WUXU~\n" +
                        "            :%`  ~#$$$m:        ~!~ ?$$$$$$\n" +
                        "          :!`.-   ~T$$$$8xx.  .xWW- ~''##*'\n" +
                        ".....   -~~:<` !    ~?T#$$@@W@*?$$      /`\n" +
                        "W$@@M!!! .!~~ !!     .:XUW$W!~ `'~:    :\n" +
                        "#'~~`.:x%`!!  !H:   !WM$$$$Ti.: .!WUn+!`\n" +
                        ":::~:!!`:X~ .: ?H.!u '$$$B$$$!W:U!T$$M~\n" +
                        ".~~   :X@!.-~   ?@WTWo('*$$$W$TH$! `\n" +
                        "Wi.~!X$?!-~    : ?$$$B$Wu('**$RM!\n" +
                        "$R@i.~~ !     :   ~$$$$$B$$en:``\n" +
                        "?MXT@Wx.~    :     ~'##*$$$$M~\n" +
                        ":::!_-~'    :        -.....-\n" +
                        "⠀▄ .▄ ▄▄▄·  ▄▄· ▄ •▄ .▄▄ ·  ▄▄▄·▄▄▌        ▪  ▄▄▄▄▄▄\n" +
                        "██▪▐█▐█ ▀█ ▐█ ▌▪█▌▄▌▪▐█ ▀. ▐█ ▄███•   ▄█▀▄ ██ ▀•██ ▀\n" +
                        "██▀▀█▄█▀▀█ ██ ▄▄▐▀▀▄·▄▀▀▀█▄ ██▀·██ ▪ ▐█▌.▐▌▐█·  ▐█.▪\n" +
                        "██▌▐▀▐█▪ ▐▌▐███▌▐█.█▌▐█▄▪▐█▐█▪·•▐█▌ ▄▐█▌.▐▌▐█▌  ▐█▌·\n" +
                        "▀▀▀ · ▀  ▀ ·▀▀▀ ·▀  ▀ ▀▀▀▀ .▀   .▀▀▀  ▀█▄▀▪▀▀▀  ▀▀▀ \n";
                    terminal.clear();
                    terminal.print(init);
                    await TerminalEmulator.sleep(1500);
                    terminal.newLine();
                    await terminal.type("₩ɆⱠ₵Ø₥Ɇ ₮Ø Ⱨ₳₵₭₴₱ⱠØł₮");
                    terminal.newLine();
                    let userName, userIP, lastIP;
                    terminal.print("ʜᴀᴄᴋꜱᴩʟᴏɪᴛ ʟᴏɢɪɴ");
                    if (terminal.user.name === "demo") {
                        terminal.setPrompt('ᴀʟɪᴀꜱ » ');
                        userName = await terminal.prompt("");
                        terminal.setPrompt(' ');
                        lastIP = "n/a";
                    } else {
                        lastIP = terminal.user.ip;
                        try {
                            const response = await fetch('https://api64.ipify.org?format=json');
                            const data = await response.json();
                            terminal.user.ip = data.ip;
                        } catch (error) {
                            console.warn('Failed to retrieve client IP:', error);
                            terminal.user.ip = `${utils.rand(255)}.${utils.rand(255)}.${utils.rand(255)}.${utils.rand(255)}`;
                        }
                        if (terminal.confirm(`Login as ${terminal.user.name} as your alias?`, true)) {
                            userName = terminal.user.name;
                        } else {
                            terminal.setPrompt('ᴀʟɪᴀꜱ » ');
                            userName = await terminal.prompt("");
                            terminal.setPrompt(' ');
                        }
                    }
                    await TerminalEmulator.sleep(1000);
                    terminal.clear();
                    terminal.print(init);
                    terminal.newLine();
                    await terminal.type("Welcome " + userName + "");
                    await TerminalEmulator.sleep(2500);
                    terminal.printHTML("<span class='info'>\nLast logged in from: " + lastIP + "</span>\nCurrently logged in from: <span class='success'>" + terminal.user.ip + "</span>\n");
                    terminal.scrollBottom();
                    await TerminalEmulator.sleep(3000);
                    terminal.printHTML("Enter a <span class='path'>hostname</span> or <span class='path'>ip address</span> to exploit:");
                    terminal.setPrompt('ʜᴀᴄᴋꜱᴩʟᴏɪᴛ » ');
                    let input = await terminal.prompt("");
                    terminal.setPrompt(' ');
                    const validInput = function(input) {
                        return utils.isHostname(input) || utils.isValidIP(input);
                    };
                    if (validInput(input)) {
                        let stdin = `hacksploit ${input} --hack`;
                        terminal.executeCommand(stdin);
                    } else {
                        terminal.printHTML("<span class='error'>\n\nYou don't belong here..</span>\nBack from whence thou came!\n");
                        await TerminalEmulator.sleep(3000);
                        terminal.setPrompt(originalPS1);
                        terminal.secondaryCommand(false);
                        terminal.clear();
                        return;
                    }
                }
                if (argv._.length > 0 && argv.hack) {
                    $("body").data("");
                    const tools = "hydra,hashcat,john,apktool,medusa,aircrack-ng,wifite,metasploit,redeye,wireshark,binwalk,fcrackzip,wifiphisher,sslscan,reaver".split(",");
                    let tool = {phase: 0, d: []};
                    let j, x, t, d, p;
                    terminal.newLine();
                    terminal.print("Downloading exploits.. please wait!\n");
                    for (let i = 0; i < utils.rand(tools.length); i++) {
                        x = tools.splice(utils.rand(tools.length - 1), 1)[0];
                        const $progress = document.createElement("span");
                        $progress.className = "progress" + x;
                        $progress.setAttribute("data-count", i);
                        terminal.stdout.appendChild($progress);
                        //terminal.printHTML($progress);
                        terminal.newLine();
                        tool.d[i] = {n: x, i: utils.history.index - 1, p: 0};
                    }
                    $("body").data(tool);
                    let stdin = `hacksploit ${argv._} -download`;
                    await terminal.executeCommand(stdin);
                }
                if (argv._.length > 0 && argv.download) {
                    $hackData = $("body").data();
                    if (!navigator.onLine) {
                        terminal.print("bash: hack: No internet connection...");
                        terminal.setPrompt(originalPS1);
                        terminal.secondaryCommand(false);
                        return;
                    }
                    if ($hackData.phase === 0) {
                        setTimeout(async function () {
                            let i = 0;
                            await $hackData.d.forEach(async function (e) {
                                if (e.p !== 100) {
                                    e.p += utils.rand(e.n.length);
                                    if (e.p > 100) {
                                        e.p = 100;
                                        i++;
                                    }
                                    await utils.showProgress(i, e.p, 100, "Import:&nbsp;" + e.n, "");
                                } else {
                                    i++;
                                }
                            });
                            $("body").data($hackData);
                            if (i === $hackData.d.length) {
                                $hackData.phase = 1;
                                $hackData.d = [' |0', 'Connection to \'' + argv._[0] + '\' (' + utils.rand(255) + '.' + utils.rand(255) + '.' + utils.rand(255) + '.' + utils.rand(255) + ')|' + (utils.rand(5000) + 500)];
                                $hackData.d = $hackData.d.concat(utils.newArray(utils.rand(10) + 5, '.|20'));
                                $hackData.d.push(' |100');
                                for (let j = 0; j < utils.rand(25) + 2; j++) {
                                    let y = utils.rand(30);
                                    for (let x = 0; x < y; x++) {
                                        $hackData.d.push((y * (x + 1)) + ' / ' + (y * y) + ' bytes|' + (utils.rand(10) + 20));
                                    }
                                    $hackData.d.push(' |120');
                                }
                                for (let j = 0; j < utils.rand(2000) + 500; j++) {
                                    $hackData.d.push(utils.createName(Math.floor(innerWidth / 8.44) - 1) + '|5');
                                }
                            }
                            $("body").data($hackData);
                            let stdin = `hacksploit ${argv._} -download`;
                            await terminal.executeCommand(stdin);
                        }, utils.rand(69) + 100);
                    } else if ($hackData.phase === 1) {
                        $hackData = $("body").data();
                        if ($hackData.d.length !== 0) {
                            let l = $hackData.d.shift().split('|');
                            terminal.write(l[0] + "\n");
                            setTimeout(async function () {
                                $("body").data($hackData);
                                let stdin = `hacksploit ${argv._} -download`;
                                await terminal.executeCommand(stdin);
                            }, parseInt(l[1]));
                            return;
                        } else {
                            $hackData.phase = 2;
                            terminal.newLine();
                            terminal.print("ACCESS GRANTED!", "success");
                            terminal.printHTML("<strong>Server Information:</strong>", "warn");
                            terminal.write("&emsp;Host: " + argv._ + " ");
                            terminal.printHTML("&emsp;Database: <span class=\"info\">phpMyAdmin v1.52.1a</span>");
                            terminal.printHTML("&emsp;Database Login: <span class=\"user\">root</span>@<span class=\"host\">" + utils.rand(255) + "." + utils.rand(255) + "." + utils.rand(255) + "." + utils.rand(255) + "</span>");
                            terminal.newLine();
                            terminal.setPrompt(originalPS1);
                            terminal.secondaryCommand(false);
                            $("body").data($hackData);
                            return;
                        }
                    }
                }
            }
        });

        terminal.registerCommand("python", {
            name: 'python',
            type: 'exec',
            help: 'Start Python REPL',
            func: async (terminal, argv) => {
                const pythonSession = new PythonREPL(terminal);
                terminal.pushSession(pythonSession);
            }
        });

        terminal.registerCommand("edit", {
            name: 'edit',
            type: 'exec', 
            help: 'Open text editor',
            aliases: ['vi', 'nano', 'vim'],
            func: async (terminal, argv) => {
                const filename = argv._[0] || 'untitled.txt';
                const editorSession = new TextEditor(terminal, filename);
                terminal.pushSession(editorSession);
            }
        });

        terminal.registerCommand("node", {
            name: 'node',
            type: 'exec', 
            help: 'Start Node.js REPL',
            func: async (terminal, argv) => {
                const nodejsSession = new NodeJS(terminal);
                terminal.pushSession(nodejsSession);
            }
        });

        terminal.registerCommand("npm", {
            name: 'npm',
            type: 'exec', 
            help: 'Search npm packages',
            func: async (terminal, argv) => {
                const npmSession = new NPM(terminal);
                terminal.pushSession(npmSession);
            }
        });

        terminal.registerCommand("github", {
            name: 'github',
            type: 'exec', 
            help: 'Start GitHub CLI',
            func: async (terminal, argv) => {
                const githubSession = new GitHubCli(terminal);
                terminal.pushSession(githubSession);
            }
        });

        let date = new Date().toString();
        date = date.substring(0, date.indexOf("GMT") - 10);
        wakeUp();
        terminal
            .printHTML(terminal.opts.welcome)
            .newLine()
            .print(`Last login: ${date}`)
            .newLine()
            .setPrompt();
    </script>
</body>
</html>
